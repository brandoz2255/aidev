'use client'

import React, { useState, useRef, useEffect } from 'react'
import Editor from '@monaco-editor/react'
import { Button } from "@/components/ui/button"
import { Card } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import {
  Play, Save, Copy, Download, Maximize2, Minimize2,
  Settings, FileText, Lightbulb
} from "lucide-react"

// CodeFile interface
interface CodeFile {
  id: string
  name: string
  content: string
  language: string
  isActive: boolean
  isModified: boolean
}

// Props interface
interface MonacoCodeEditorProps {
  files: CodeFile[]
  activeFileId: string
  onFileChange: (fileId: string, content: string) => void
  onSaveFile?: (fileId: string) => void
  onRunFile?: (fileId: string) => void
  onRequestCompletion?: (fileId: string, position: any, context: string) => Promise<string[]>
  className?: string
}

const MonacoCodeEditor: React.FC<MonacoCodeEditorProps> = ({
  files,
  activeFileId,
  onFileChange,
  onSaveFile,
  onRunFile,
  onRequestCompletion,
  className = ""
}) => {
  const [isFullscreen, setIsFullscreen] = useState(false)
  const [isLoading, setIsLoading] = useState(true)
  const editorRef = useRef<any>(null)
  const monacoRef = useRef<any>(null)

  const activeFile = files.find(file => file.id === activeFileId)

  // Define vibe-dark theme
  const defineVibeTheme = (monaco: any) => {
    monaco.editor.defineTheme('vibe-dark', {
      base: 'vs-dark',
      inherit: true,
      rules: [
        { token: 'comment', foreground: '6A9955', fontStyle: 'italic' },
        { token: 'keyword', foreground: '569CD6' },
        { token: 'string', foreground: 'CE9178' },
        { token: 'number', foreground: 'B5CEA8' },
        { token: 'type', foreground: '4EC9B0' },
        { token: 'function', foreground: 'DCDCAA' },
      ],
      colors: {
        'editor.background': '#1a1a1a',
        'editor.foreground': '#d4d4d4',
        'editor.lineHighlightBackground': '#2d2d30',
        'editor.selectionBackground': '#264f78',
        'editor.inactiveSelectionBackground': '#3a3d41',
      }
    })
  }

  // Editor configuration
  const editorOptions = {
    fontSize: 14,
    theme: 'vibe-dark',
    wordWrap: 'on' as const,
    minimap: { enabled: true },
    lineNumbers: 'on' as const,
    autoClosingBrackets: 'always' as const,
    autoClosingQuotes: 'always' as const,
    formatOnPaste: true,
    formatOnType: true,
    automaticLayout: true,
    scrollBeyondLastLine: false,
    contextmenu: true,
    quickSuggestions: {
      other: true,
      comments: true,
      strings: true
    },
    suggestOnTriggerCharacters: true,
    acceptSuggestionOnEnter: 'on' as const,
    tabCompletion: 'on' as const,
    wordBasedSuggestions: 'matchingDocuments' as const,
    inlineSuggest: { enabled: true },
    bracketPairColorization: { enabled: true },
    guides: {
      bracketPairs: true,
      indentation: true
    }
  }

  // Handle editor mount
  const handleEditorDidMount = (editor: any, monaco: any) => {
    editorRef.current = editor
    monacoRef.current = monaco
    
    // Define custom theme
    defineVibeTheme(monaco)
    monaco.editor.setTheme('vibe-dark')
    
    // Set up AI completion provider if available
    if (onRequestCompletion) {
      const completionProvider = monaco.languages.registerCompletionItemProvider(
        activeFile?.language || 'python',
        {
          provideCompletionItems: async (model: any, position: any) => {
            const textUntilPosition = model.getValueInRange({
              startLineNumber: Math.max(1, position.lineNumber - 10),
              startColumn: 1,
              endLineNumber: position.lineNumber,
              endColumn: position.column,
            })
            
            try {
              const suggestions = await onRequestCompletion(activeFileId, position, textUntilPosition)
              return {
                suggestions: suggestions.map((suggestion, index) => ({
                  label: suggestion,
                  kind: monaco.languages.CompletionItemKind.Text,
                  insertText: suggestion,
                  detail: 'AI Suggestion',
                  documentation: 'Generated by AI assistant',
                  sortText: `0${index}`,
                }))
              }
            } catch (error) {
              console.error('AI completion error:', error)
              return { suggestions: [] }
            }
          },
          triggerCharacters: ['.', ' ', '(', '[', '{']
        }
      )
    }
    
    setIsLoading(false)
  }

  // Handle content change
  const handleEditorChange = (value: string | undefined) => {
    if (value !== undefined && activeFile) {
      onFileChange(activeFileId, value)
    }
  }

  // Action handlers
  const handleFormatCode = () => {
    if (editorRef.current) {
      editorRef.current.getAction('editor.action.formatDocument').run()
    }
  }

  const handleCopyContent = async () => {
    if (activeFile) {
      await navigator.clipboard.writeText(activeFile.content)
    }
  }

  const handleDownloadFile = () => {
    if (activeFile) {
      const blob = new Blob([activeFile.content], { type: 'text/plain' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = activeFile.name
      a.click()
      URL.revokeObjectURL(url)
    }
  }

  const handleSaveFile = () => {
    if (onSaveFile && activeFile) {
      onSaveFile(activeFileId)
    }
  }

  const handleRunFile = () => {
    if (onRunFile && activeFile) {
      onRunFile(activeFileId)
    }
  }

  const toggleFullscreen = () => {
    setIsFullscreen(!isFullscreen)
  }

  if (!activeFile) {
    return (
      <Card className="p-8 text-center">
        <FileText className="mx-auto mb-4 h-12 w-12 text-muted-foreground" />
        <p className="text-muted-foreground">No file selected</p>
      </Card>
    )
  }

  return (
    <div className={`monaco-editor-container ${isFullscreen ? 'fixed inset-0 z-50 bg-background' : ''} ${className}`}>
      <Card className="h-full flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-3 border-b">
          <div className="flex items-center gap-2">
            <Badge variant="outline">{activeFile.language}</Badge>
            <span className="font-medium">{activeFile.name}</span>
            {activeFile.isModified && (
              <Badge variant="secondary" className="text-xs">Modified</Badge>
            )}
          </div>
          
          <div className="flex items-center gap-1">
            <Button
              variant="ghost"
              size="sm"
              onClick={handleFormatCode}
              title="Format Code"
            >
              <Settings className="h-4 w-4" />
            </Button>
            
            <Button
              variant="ghost"
              size="sm"
              onClick={handleCopyContent}
              title="Copy to Clipboard"
            >
              <Copy className="h-4 w-4" />
            </Button>
            
            <Button
              variant="ghost"
              size="sm"
              onClick={handleDownloadFile}
              title="Download File"
            >
              <Download className="h-4 w-4" />
            </Button>
            
            {onSaveFile && (
              <Button
                variant="ghost"
                size="sm"
                onClick={handleSaveFile}
                title="Save File"
              >
                <Save className="h-4 w-4" />
              </Button>
            )}
            
            {onRunFile && (
              <Button
                variant="default"
                size="sm"
                onClick={handleRunFile}
                title="Run File"
                className="bg-green-600 hover:bg-green-700"
              >
                <Play className="h-4 w-4" />
              </Button>
            )}
            
            <Button
              variant="ghost"
              size="sm"
              onClick={toggleFullscreen}
              title={isFullscreen ? "Exit Fullscreen" : "Fullscreen"}
            >
              {isFullscreen ? (
                <Minimize2 className="h-4 w-4" />
              ) : (
                <Maximize2 className="h-4 w-4" />
              )}
            </Button>
          </div>
        </div>

        {/* Editor */}
        <div className="flex-1 relative">
          {isLoading && (
            <div className="absolute inset-0 flex items-center justify-center bg-background/80">
              <div className="flex items-center gap-2">
                <Lightbulb className="h-5 w-5 animate-pulse" />
                <span>Loading editor...</span>
              </div>
            </div>
          )}
          
          <Editor
            height="100%"
            language={activeFile.language}
            value={activeFile.content}
            options={editorOptions}
            onMount={handleEditorDidMount}
            onChange={handleEditorChange}
            loading={null}
          />
        </div>
      </Card>
    </div>
  )
}

export default MonacoCodeEditor